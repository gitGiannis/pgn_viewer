# -------------------------------------------------------------------------------------------------------------------- #
# gameplay.py: περιέχει την κλάση Gameplay                                                                             #
# -------------------------------------------------------------------------------------------------------------------- #
from board import Board


class Gameplay:
    """
    Συνδυάζει τις πληροφορίες που έχει αποσπάσει το FilePGN και τα στοιχεία του Board, διαχειρίζεται τα Piece (κομμάτια)
    του πίνακα ελέγχοντας ποιο κομμάτι πρέπει να κινηθεί και σε ποια θέση
    Χρησιμοποιεί τη λίστα με τις κινήσεις από το αρχείο pgn, έπειτα πραγματοποιώντας τους κατάλληλους ελέγχους μεταβάλει
    τη "σκακιέρα"
    Επειδή δεν υπάρχει η δυνατότητα να κινηθούμε "προς τα πίσω", στους προηγούμενους γύρους δηλαδή, η κλάση αυτή
    χρησιμοποιείται από την κλάση game_loader.GameLoader, η οποία αποθηκεύει στιγμιότυπα του κάθε γύρου

    Ορίσματα:
    ---------
        list_of_moves (list):
            λίστα με τις επεξεργασμένες κινήσεις του αγώνα

    Μέθοδοι:
    --------
        next_move(self) -> str | None:
            εκτέλεση επόμενης κίνησης, επιστρέφει το όνομα του κομματιού που αιχμαλωτίστηκε

        __diagonal_move_is_valid(self, src: str, dest: str) -> bool:
            ελέγχει εάν η διαγώνια κίνηση ενός κομματιού είναι έγκυρη

        __horizontal_or_vertical_move_is_valid(self, src: str, dest: str) -> bool:
            ελέγχει εάν η οριζόντια/κάθετη κίνηση ενός κομματιού είναι έγκυρη

        __knight_move_is_valid(self, src: str, dest: str) -> bool:
            ελέγχει εάν η κίνηση ενός ίππου είναι έγκυρη

        __king_move_is_valid(self, src: str, dest: str) -> bool:
            ελέγχει εάν η κίνηση του βασιλιά είναι έγκυρη

        __piece_is_not_pinned(self, src: str, dest: str, tag: str) -> bool:
            ελέγχει εάν ένα κομμάτι είναι "καρφωμένο"
    """
    def __init__(self, list_of_moves: list):
        # αρχικοποίηση κλάσης Board ------------------------------------------------------------------------------------
        self.brd = Board()

        # δημιουργία λεξικού με τις επεξεργασμένες πληροφορίες του παιχνιδιού που επιλέχτηκε από το οποίο κρατάω το ----
        # key-word "moves": επιστρέφει λίστα με τις κινήσεις του συγκεκριμένου παιχνιδιού
        self.moves = list_of_moves

        # αποθήκευση μήκους λίστας κινήσεων
        self.moves_length = len(self.moves)

        # αρχικοποίηση λιστών με πληροφορίες για τον έλεγχο των κινήσεων -----------------------------------------------
        # λίστα με τις στήλες της σκακιέρας
        self.files = ["a", "b", "c", "d", "e", "f", "g", "h"]
        # λίστα με τις σειρές της σκακιέρας
        self.ranks = ["1", "2", "3", "4", "5", "6", "7", "8"]
        # λίστα με τις διαγωνίους της σκακιέρας
        self.diags = [["a1", "b2", "c3", "d4", "e5", "f6", "g7", "h8"],
                      ["a2", "b3", "c4", "d5", "e6", "f7", "g8"],
                      ["a3", "b4", "c5", "d6", "e7", "f8"],
                      ["a4", "b5", "c6", "d7", "e8"],
                      ["a5", "b6", "c7", "d8"],
                      ["a6", "b7", "c8"],
                      ["a7", "b8"],
                      ["a8", "b7", "c6", "d5", "e4", "f3", "g2", "h1"],
                      ["a7", "b6", "c5", "d4", "e3", "f2", "g1"],
                      ["a6", "b5", "c4", "d3", "e2", "f1", ],
                      ["a5", "b4", "c3", "d2", "e1"],
                      ["a4", "b3", "c2", "d1"],
                      ["a3", "b2", "c1"],
                      ["a2", "b1"],
                      ["h2", "g3", "f4", "e5", "d6", "c7", "b8"],
                      ["h3", "g4", "f5", "e6", "d7", "c8"],
                      ["h4", "g5", "f6", "e7", "d8"],
                      ["h5", "g6", "f7", "e8"],
                      ["h6", "g7", "f8"],
                      ["h7", "g8"],
                      ["h7", "g6", "f5", "e4", "d3", "c2", "b1"],
                      ["h6", "g5", "f4", "e3", "d2", "c1"],
                      ["h5", "g4", "f3", "e2", "d1"],
                      ["h4", "g3", "f2", "e1"],
                      ["h3", "g2", "f1"],
                      ["h2", "g1"]
                      ]
        # η λίστα knight_moves περιέχει όλες τις πιθανές κινήσεις (σημεία) για τον ίππο,
        # θεωρώντας ότι ο ίππος βρίσκεται στη θέση (0, 0)
        self.knight_moves = [(-2, -1), (-2, 1), (2, -1), (2, 1),
                             (-1, -2), (-1, 2), (1, -2), (1, 2)]

        # αρχικοποίηση μεταβλητής που μετράει τους γύρους
        self.round = -1

        # αρχικοποίηση βοηθητικών μεταβλητών (για τη γραφική αναπαράσταση) ---------------------------------------------
        # δήλωση ότι ο βασιλιάς έχει ματ
        self.check = None
        # δήλωση ότι έχει γίνει κατάληψη κομματιού
        self.capture = False

    def next_move(self) -> str | None:
        """
        Εκτέλεση επόμενης κίνησης
        Ανάλογα την εκάστοτε κίνηση, γίνεται έλεγχος των κομματιών και μετακίνηση του κατάλληλου

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (str | None):
                (str) το όνομα (piece.name) του κομματιού που αιχμαλωτίστηκε
                (None) δεν πραγματοποιήθηκε κάποια κίνηση (πιθανό εσφαλμένο αρχείο)
        """
        # επαναφορά των βοηθητικών μεταβλητών στην προκαθορισμένη τιμή
        self.check = None
        self.capture = False

        # επαύξηση γύρου
        self.round += 1
        # στήσιμο των κομματιών
        self.brd.update_self()
        # εναλλαγή δείκτη παίκτη που πρόκειται να παίξει (λευκός - μαύρος)
        if self.round % 2 == 0:
            tag = "w"
        else:  # self.round % 2 == 1
            tag = "b"

        # αποθήκευση τρέχουσας κίνησης
        move = self.moves[self.round]

        if "x" in move:
            # κάποιο κομμάτι αιχμαλωτίστηκε, οπότε η self.capture για αυτόν τον γύρο γίνεται True
            # θα χρησιμοποιηθεί από την gui.GUI για την αναπαραγωγή των ήχων
            self.capture = True

        # ειδικές κινήσεις / σημάνσεις κινήσεων ------------------------------------------------------------------------
        # >> εξαιρετική κίνηση / λανθάνουσα κίνηση <<
        if "!" in move or "?" in move:
            move = move[:len(move) - 1]
            if "!" in move or "?" in move:
                move = move[:len(move) - 1]

        # >> check / checkmate <<
        if "+" in move or "#" in move:
            # με αυτήν τη βοηθητική μεταβλητή δηλώνεται ότι σε αυτόν τον γύρο έχει ματ ο βασιλιάς
            self.check = "b" if tag == "w" else "w"
            move = move[:len(move) - 1]

        # >> ροκέ <<
        if move == "O-O" or move == "O-O-O":
            # η κινήσεις O-O και 0-0-0 ονομάζονται μικρό και μεγάλο ροκέ αντίστοιχα
            for piece in self.brd.pieces:
                if piece.name[0] == "k" and piece.name[1] == tag:
                    if tag == "w":
                        if move == "O-O":
                            # o βασιλιάς κάνει μικρό ροκέ με τον δεξί πύργο
                            self.brd.move_piece(piece.pos, "g1")
                            self.brd.move_piece("h1", "f1")
                            return "   "
                        if move == "O-O-O":
                            # o βασιλιάς κάνει μεγάλο ροκέ με τον αριστερό πύργο
                            self.brd.move_piece(piece.pos, "c1")
                            self.brd.move_piece("a1", "d1")
                            return "   "

                    elif tag == "b":
                        if move == "O-O":
                            # o βασιλιάς κάνει μικρό ροκέ με τον δεξί πύργο
                            self.brd.move_piece(piece.pos, "g8")
                            self.brd.move_piece("h8", "f8")
                            return "   "
                        if move == "O-O-O":
                            # o βασιλιάς κάνει μεγάλο ροκέ με τον αριστερό πύργο
                            self.brd.move_piece(piece.pos, "c8")
                            self.brd.move_piece("a8", "d8")
                            return "   "

        # >> εξέλιξη πιονιού <<
        pawn_promotion = False
        # μεταβλητή για αποθήκευση χαρακτηρισμού προαγωγής πιονιού
        # ("q"=προαγωγή σε βασίλισσα, "r"=προαγωγή σε πύργο κ.ο.κ.)
        promotion = ""
        # μεταβλητή για αποθήκευση ονόματος αιχμαλωτισμένου πιονιού εάν έχουμε en-passant (εν-διελεύσει)
        # στη συγκεκριμένη περίπτωση το πιόνι εκτελεί "κρυφά" δύο κινήσεις όπως θα φανεί παρακάτω
        en_passant = ""

        if "=" in move:
            # έχουμε εξέλιξη πιονιού σε αυτόν τον γύρο (πχ e8=Q ή fxe8=R κλπ)
            pawn_promotion = True
            # κρατάω την πληροφορία που με ενδιαφέρει (σε τι προήχθη το πιόνι) και κρατάω την υπόλοιπη κίνηση σαν μία
            # απλή κίνηση (πχ e8=Q -> promotion == q και move == e8)
            promotion = move[-1].lower()
            move = move[:len(move) - 2]

        # κίνηση πιονιού -----------------------------------------------------------------------------------------------
        if len(move) == 2 or (len(move) == 4 and move[0].islower() and move[1] == "x"):
            # απλή κίνηση μπροστά (πχ e4)
            if len(move) == 2:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρω το πιόνι που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι πιόνι κατάλληλου αρώματος και κατάλληλης στήλης (file)
                    if piece.name[0] == "p" and piece.name[1] == tag and piece.pos[0] == move[0]:
                        # τα λευκά πιόνια αυξάνουν το rank της θέσης τους όταν μετακινούνται, επομένως η διαφορά
                        # της μελλοντικής θέσης με την τρέχουσα είναι θετική
                        # για τα μαύρα πιόνια ισχύει το αντίθετο (η διαφορά είναι αρνητική)
                        diff_in_rank_after_moving = int(move[1]) - int(piece.pos[1])

                        # ένα πιόνι δεν μπορεί να μετακινηθεί πάνω από δύο θέσεις, ούτε να αλλάξει στήλη σε απλή κίνηση
                        if diff_in_rank_after_moving < -2 or diff_in_rank_after_moving > 2 or piece.pos[0] != move[0]:
                            continue

                        # ένα πιόνι δεν μπορεί να έχει να κινηθεί προς τα πίσω
                        if (diff_in_rank_after_moving > 0 and piece.name[1] == "b") or \
                           (diff_in_rank_after_moving < 0 and piece.name[1] == "w"):
                            continue

                        # για να κινηθεί ένα πιόνι δύο κελιά εμπρός, πρέπει να βρίσκεται απαραίτητα στην αρχική του θέση
                        if (diff_in_rank_after_moving == 2 and piece.pos[1] != "2") or \
                           (diff_in_rank_after_moving == -2 and piece.pos[1] != "7"):
                            continue

                        # για να μετακινηθεί ένα πιόνι δύο θέσεις, θα πρέπει να έχει ελεύθερο το κελί μπροστά του
                        if diff_in_rank_after_moving == 2 and self.brd.squares[move[0] + str(int(piece.pos[1]) + 1)]:
                            # ένα λευκό πιόνι προσπάθησε να μετακινηθεί δύο θέσεις μπροστά, αλλά ήταν διπλωμένο
                            # (είχε ακριβώς μπροστά του φίλιο πιόνι το οποίο θα κινηθεί μία θέση)
                            continue
                        if diff_in_rank_after_moving == -2 and self.brd.squares[move[0] + str(int(piece.pos[1]) - 1)]:
                            # ένα μαύρο πιόνι προσπάθησε να μετακινηθεί δύο θέσεις μπροστά, αλλά ήταν διπλωμένο
                            # (είχε ακριβώς μπροστά του φίλιο πιόνι το οποίο θα κινηθεί μία θέση)
                            continue

                        # εάν δεν ισχύει καμία από τις παραπάνω συνθήκες, το πιόνι μπορεί να προχωρήσει μπροστά
                        # γίνεται έλεγχος προαγωγής
                        if pawn_promotion:
                            # το πιόνι έφτασε στην απέναντι μεριά της σκακιέρας, οπότε προάγεται και αλλάζει το όνομά
                            # του και πλέον θεωρείται τύπου "promotion" (μπορεί να είναι "q", "r", "n" ή "b")
                            piece.name = promotion + tag + "+"
                        return self.brd.move_piece(piece.pos, move)

            # το πιόνι αιχμαλωτίζει (πχ dxe4)
            elif len(move) == 4 and move[0].islower() and move[1] == "x":
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρω το πιόνι που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι πιόνι κατάλληλου χρώματος και στήλης (file)
                    if piece.name[0] == "p" and piece.name[1] == tag and piece.pos[0] == move[0]:
                        # προσωρινή αποθήκευση rank πιονιού
                        piece_rank = int(piece.pos[1])
                        # έλεγχος εάν η κίνηση αυτή είναι εφικτή από το πιόνι
                        if (tag == "w" and piece_rank + 1 != int(move[3])) or \
                           (tag == "b" and piece_rank - 1 != int(move[3])):
                            # εδώ γίνεται έλεγχος αν το πιόνι που βρέθηκε μπορεί να αιχμαλωτίσει
                            # πρέπει το rank να είναι κατά μία μονάδα μικρότερο για τα λευκά ή μία μονάδα μεγαλύτερο για
                            # τα μαύρα
                            continue

                        # έλεγχος εάν η κίνηση (κατάληψης) έγινε σε κενό κελί (εάν ναι έχουμε "en passant")
                        if not self.brd.squares[move[2:]]:
                            # ένα πιόνι αιχμαλώτισε κενό κελί, σημαίνει ότι έχουμε "en passant" (εν διελεύσει)
                            # το πιόνι θα κινηθεί "κρυφά" αιχμαλωτίζοντας το κομμάτι
                            # και μετά θα κινηθεί στην πραγματική του θέση
                            if tag == "w":
                                # κάποιο λευκό πιόνι εκτέλεσε "en passant"
                                # το νέο προσωρινό rank του πιονιού
                                temporary_rank = int(move[3]) - 1
                                # η προσωρινή κίνηση
                                temporary_move = move[2] + str(temporary_rank)
                                # προσωρινή κίνηση (δεξιά ή αριστερά) για κατάληψη του αντίπαλου πιονιού
                                en_passant = self.brd.move_piece(piece.pos, temporary_move)

                            elif tag == "b":
                                # κάποιο μαύρο πιόνι εκτέλεσε "en passant"
                                temporary_rank = int(move[3]) + 1
                                temporary_move = move[2] + str(temporary_rank)
                                # προσωρινή κίνηση (δεξιά ή αριστερά) για κατάληψη του αντίπαλου πιονιού
                                en_passant = self.brd.move_piece(piece.pos, temporary_move)

                        # εάν ταυτόχρονα με την κατάληψη, υπάρχει και προαγωγή του πιονιού, αλλάζει το όνομά του και
                        # πλέον θεωρείται τύπου "promotion" (μπορεί να είναι "q", "r", "n" ή "b")
                        if pawn_promotion:
                            piece.name = promotion + tag + "+"

                        # εδώ πραγματοποιείται η τελική (πραγματική) κίνηση του πιονιού
                        # (εάν είχε εκτελέσει και en-passant)
                        # αποθηκεύεται το όνομα του αιχμαλωτισμένου κομματιού
                        captured_piece_name = self.brd.move_piece(piece.pos, move[2:])
                        if captured_piece_name != "   ":
                            # επειδή η κίνηση περιελάμβανε τον χαρακτήρα "x", πρέπει να επιστραφεί το όνομα του
                            # αιχμαλωτισμένου κομματιού
                            # (διαφορετικό της "   ", που σημαίνει ότι το πιόνι απλώς μετακινήθηκε)
                            return captured_piece_name
                        if en_passant:
                            # εάν το en_passant έχει λάβει τιμή διαφορετική του "", σημαίνει ότι το αντίπαλο κομμάτι
                            # αιχμαλωτίστηκε κατά την κρυφή κίνηση "en_passant"
                            return en_passant

        # κίνηση βασιλιά (king K) --------------------------------------------------------------------------------------
        elif move[0] == "K":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο βασιλιάς
            for piece in self.brd.pieces:
                # εύρεση βασιλιά (μοναδικό κομμάτι)
                if piece.name[0] == "k" and piece.name[1] == tag:
                    # έλεγχος εάν η κίνηση του βασιλιά είναι εφικτή
                    if self.__king_move_is_valid(piece.pos, move[1:]):
                        # μετακίνηση βασιλιά
                        return self.brd.move_piece(piece.pos, move[1:])

        # κίνηση βασίλισσας (Queen Q) ----------------------------------------------------------------------------------
        elif move[0] == "Q":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση Q__: βασίλισσα μετακινείται (πχ Qf3)
            if len(move) == 3:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί η βασίλισσα που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι βασίλισσα κατάλληλου χρώματος
                    if piece.name[0] == "q" and piece.name[1] == tag:
                        # έλεγχος εάν η διαγώνια ή η οριζόντια/κάθετη κίνηση της βασίλισσας είναι επιτρεπτή
                        if self.__diagonal_move_is_valid(src=piece.pos, dest=move[1:]) or \
                           self.__horizontal_or_vertical_move_is_valid(src=piece.pos, dest=move[1:]):
                            # έλεγχος εάν η βασίλισσα δεν είναι καρφωμένη στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση βασίλισσας
                                return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις Q___: συγκεκριμένη βασίλισσα μετακινείται (πχ Qcb4 ή Q3b4)
            if len(move) == 4:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί η βασίλισσα που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι βασίλισσα κατάλληλου χρώματος
                    if piece.name[0] == "q" and piece.name[1] == tag:
                        # έλεγχος εάν είναι βασίλισσα κατάλληλης θέσης
                        if piece.pos[0] == move[1] or piece.pos[1] == move[1]:
                            # έλεγχος εάν η διαγώνια ή η οριζόντια/κάθετη κίνηση της βασίλισσας είναι επιτρεπτή
                            if self.__diagonal_move_is_valid(piece.pos, move[2:]) or \
                               self.__horizontal_or_vertical_move_is_valid(piece.pos, move[2:]):
                                # έλεγχος εάν η βασίλισσα δεν είναι καρφωμένη στον βασιλιά
                                if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                    # μετακίνηση βασίλισσας
                                    return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις Q____: συγκεκριμένη βασίλισσα μετακινείται (πχ Qb1b4)
            elif len(move) == 5:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί η βασίλισσα που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι βασίλισσα κατάλληλου χρώματος και κατάλληλης θέσης
                    if piece.name[0] == "q" and piece.name[1] == tag and piece.pos == move[1:3]:
                        # έλεγχος εάν η διαγώνια ή η οριζόντια/κάθετη κίνηση της βασίλισσας είναι επιτρεπτή
                        if self.__diagonal_move_is_valid(piece.pos, move[3:]) or \
                           self.__horizontal_or_vertical_move_is_valid(piece.pos, move[3:]):
                            # έλεγχος εάν η βασίλισσα δεν είναι καρφωμένη στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση βασίλισσας
                                return self.brd.move_piece(piece.pos, move[3:])

        # κίνηση ίππου (knight N) --------------------------------------------------------------------------------------
        elif move[0] == "N":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση N__: ίππος μετακινείται (πχ Nf3)
            if len(move) == 3:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο ίππος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι ίππος κατάλληλου χρώματος
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        # έλεγχος εάν η κίνηση του ίππου είναι επιτρεπτή
                        if self.__knight_move_is_valid(src=piece.pos, dest=move[-2:]):
                            # έλεγχος ότι ο ίππος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση ίππου
                                return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις N___: συγκεκριμένος ίππος μετακινείται (πχ Nfb4 ή N1b4)
            elif len(move) == 4:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο ίππος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι ίππος κατάλληλου χρώματος
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        # έλεγχος εάν είναι ίππος κατάλληλης θέσης
                        if piece.pos[0] == move[1] or piece.pos[1] == move[1]:
                            # έλεγχος εάν η κίνηση του ίππου είναι επιτρεπτή
                            if self.__knight_move_is_valid(src=piece.pos, dest=move[-2:]):
                                # έλεγχος ότι ο ίππος δεν είναι καρφωμένος στον βασιλιά
                                if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                    # μετακίνηση ίππου
                                    return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις N____: συγκεκριμένος ίππος μετακινείται (πχ Nd3b5)
            elif len(move) == 5:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο ίππος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι ίππος κατάλληλου χρώματος και κατάλληλης θέσης
                    if piece.name[0] == "n" and piece.name[1] == tag and piece.pos == move[1:3]:
                        # έλεγχος εάν η κίνηση του ίππου είναι επιτρεπτή
                        if self.__knight_move_is_valid(src=piece.pos, dest=move[-2:]):
                            # έλεγχος ότι ο ίππος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση ίππου
                                return self.brd.move_piece(piece.pos, move[3:])

        # κίνηση αξιωματικού (bishop B) --------------------------------------------------------------------------------
        elif move[0] == "B":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση B__: αξ/κος μετακινείται (πχ Bf3)
            if len(move) == 3:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο αξ/κος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι αξ/κος κατάλληλου χρώματος
                    if piece.name[0] == "b" and piece.name[1] == tag:
                        # έλεγχος εάν η διαγώνια κίνηση του αξ/κού είναι επιτρεπτή
                        if self.__diagonal_move_is_valid(src=piece.pos, dest=move[1:]):
                            # έλεγχος ότι ο αξ/κος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση αξ/κού
                                return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις B___: συγκεκριμένος αξ/κος μετακινείται (πχ Bcb4 ή B3b4)
            elif len(move) == 4:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο αξ/κος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι αξ/κος κατάλληλου χρώματος
                    if piece.name[0] == "b" and piece.name[1] == tag:
                        # έλεγχος εάν είναι αξ/κος κατάλληλης θέσης
                        if piece.pos[0] == move[1] or piece.pos[1] == move[1]:
                            # έλεγχος εάν η διαγώνια κίνηση του αξ/κού είναι επιτρεπτή
                            if self.__diagonal_move_is_valid(src=piece.pos, dest=move[2:]):
                                # έλεγχος ότι ο αξ/κος δεν είναι καρφωμένος στον βασιλιά
                                if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                    # μετακίνηση αξ/κού
                                    return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις B____: συγκεκριμένος αξ/κος μετακινείται (πχ Bb1e4)
            elif len(move) == 5:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο αξ/κος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι αξ/κος κατάλληλου χρώματος και κατάλληλης θέσης
                    if piece.name[0] == "b" and piece.name[1] == tag and piece.pos == move[1:3]:
                        # έλεγχος εάν η διαγώνια κίνηση του αξ/κού είναι επιτρεπτή
                        if self.__diagonal_move_is_valid(src=piece.pos, dest=move[3:]):
                            # έλεγχος ότι ο αξ/κος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση αξ/κού
                                return self.brd.move_piece(piece.pos, move[3:])

        # κίνηση πύργου (rook R) ---------------------------------------------------------------------------------------
        elif move[0] == "R":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση R__: πύργος μετακινείται (πχ Rf3)
            if len(move) == 3:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο πύργος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "r" and piece.name[1] == tag:
                        # έλεγχος εάν η οριζόντια/κάθετη κίνηση του πύργου είναι επιτρεπτή
                        if self.__horizontal_or_vertical_move_is_valid(src=piece.pos, dest=move[1:]):
                            # έλεγχος ότι ο πύργος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση πύργου
                                return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις R___: συγκεκριμένος πύργος μετακινείται (πχ Rbb4 ή R4b4)
            elif len(move) == 4:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο πύργος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "r" and piece.name[1] == tag:
                        # έλεγχος εάν είναι στην κατάλληλη θέση
                        if piece.pos[0] == move[1] or piece.pos[1] == move[1]:
                            # έλεγχος εάν η οριζόντια/κάθετη κίνηση του πύργου είναι επιτρεπτή
                            if self.__horizontal_or_vertical_move_is_valid(src=piece.pos, dest=move[2:]):
                                # έλεγχος ότι ο πύργος δεν είναι καρφωμένος στον βασιλιά
                                if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                    # μετακίνηση πύργου
                                    return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις R____: συγκεκριμένος πύργος μετακινείται (πχ Rb1b4)
            elif len(move) == 5:
                # διαπέραση του πίνακα με τα κομμάτια μέχρι να βρεθεί ο πύργος που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # έλεγχος εάν είναι πύργος κατάλληλου χρώματος και κατάλληλης θέσης
                    if piece.name[0] == "r" and piece.name[1] == tag and piece.pos == move[1:3]:
                        # έλεγχος εάν η οριζόντια/κάθετη κίνηση του πύργου είναι επιτρεπτή
                        if self.__horizontal_or_vertical_move_is_valid(src=piece.pos, dest=move[1:3]):
                            # έλεγχος ότι ο πύργος δεν είναι καρφωμένος στον βασιλιά
                            if self.__piece_is_not_pinned(src=piece.pos, dest=move[-2:], tag=tag):
                                # μετακίνηση πύργου
                                return self.brd.move_piece(piece.pos, move[1:3])

        # η συνάρτηση επιστρέφει None σε περίπτωση που δεν έχει εκτελεστεί κάποια κίνηση
        # σημαίνει ότι κατά πάσα πιθανότητα το αρχείο δεν είναι σωστό
        return None

    def __diagonal_move_is_valid(self, src: str, dest: str) -> bool:
        """
        Ελέγχει εάν η διαγώνια κίνηση ενός κομματιού είναι έγκυρη
        Υπάρχει η πιθανότητα δύο αξιωματικοί να βρίσκονται στην ίδια διαγώνιο, ο ένας όμως να εμποδίζεται να κινηθεί από
        κάποιο άλλο κομμάτι
        Σε αυτήν την περίπτωση πρέπει να ελεγχθεί έαν η διαδρομή του από το σημείο εκκίνησης εώς το σημείο προορισμού
        είναι ελεύθερη
        Διαφορετικά θα μετακινηθεί ο πρώτος που θα βρεθεί στη διαπέραση των κομματιών, και θα εκτελέσει μη νόμιμη κίνηση
        Ορίσματα:
        ---------
            src (str): θέση εκκίνησης (πχ e4)

            dest (str): θέση προορισμού (πχ g6)

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (bool):
                True: η κίνηση είναι έγκυρη
                False: η κίνηση δεν είναι έγκυρη
        """
        if src == dest:
            # έλεγχος εάν έχουμε ίδια θέση εκκίνησης - προορισμού (δεν επιτρέπεται)
            return False

        # αρχικοποίηση βοηθητικής μεταβλητής
        # όταν είναι True δηλώνει ότι είμαστε ενδιάμεσα από τις δύο θέσεις
        in_range_flag = False
        # διαπέραση όλων των διαγωνίων για να βρεθεί αν σε κάποια διαγώνιο συνυπάρχουν θέση κομματιού (src) και
        # θέση επίθεσης (dest)
        for diag in self.diags:
            # ο έλεγχος θα επιτύχει εάν και τα δύο βρίσκονται στην ίδια διαγώνιο
            if src in diag and dest in diag:
                # κομμάτι και θέση επίθεσης βρίσκονται στην ίδια διαγώνιο
                # για να μπορεί να εκτελεστεί η κίνηση από αυτό το κομμάτι, θα πρέπει όλα τα κελιά ενδιάμεσα να είναι
                # κενά
                for square in diag:
                    # διατρέχουμε τα κελιά μέχρι να βρούμε το ένα απο τα δύο (κομμάτι ή θέση επίθεσης)
                    if square != src and square != dest and in_range_flag is False:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    # όταν βρεθεί το ένα, ενεργοποιείται το flag, ώστε να ξεκινήσει ο έλεγχος
                    # το flag απενεργοποιείται μόλις βρεθεί και το δεύτερο
                    if square == src or square == dest:
                        # την πρώτη φορά που θα ισχύσει η συνθήκη, σημαίνει ότι είμαστε εντός εύρους
                        # κίνησης και ενεργοποιείται το flag (χρησιμοποιείται στον έλεγχο παρακάτω)
                        # τη δεύτερη φορά σημαίνει ότι βγαίνουμε από το εύρος και απενεργοποιείται
                        in_range_flag = not in_range_flag
                        continue
                    # όσο το flag είναι ενεργό, πραγματοποιείται έλεγχος των κελιών
                    if in_range_flag:
                        # εάν κάποιο από τα κελιά είναι ενεργό, διακόπτεται η αναζήτηση
                        if self.brd.squares[square]:
                            return False

                # εάν το for τελειώσει ομαλά, η διαδρομή του αξιωματικού είναι ελεύθερη
                # και μπορεί να μετακινηθεί
                else:
                    return True
        return False

    def __horizontal_or_vertical_move_is_valid(self, src: str, dest: str) -> bool:
        """
        Ελέγχει εάν η οριζόντια/κάθετη κίνηση ενός κομματιού είναι έγκυρη
        Υπάρχει η πιθανότητα δύο πύργοι να βρίσκονται στην ίδια στήλη/γραμμή, ο ένας όμως να εμποδίζεται να κινηθεί από
        κάποιο άλλο κομμάτι
        Σε αυτήν την περίπτωση πρέπει να ελεγχθεί έαν η διαδρομή του από το σημείο εκκίνησης εώς το σημείο προορισμού
        είναι ελεύθερη
        Διαφορετικά θα μετακινηθεί ο πρώτος που θα βρεθεί στη διαπέραση των κομματιών, και θα εκτελέσει μη νόμιμη κίνηση
        Ορίσματα:
        ---------
            src (str): θέση εκκίνησης (πχ e4)

            dest (str): θέση προορισμού (πχ e6)

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (bool):
                True: η κίνηση είναι έγκυρη
                False: η κίνηση δεν είναι έγκυρη
        """
        if src == dest:
            # έλεγχος εάν έχουμε ίδια θέση εκκίνησης - προορισμού (δεν επιτρέπεται)
            return False

        if src[0] == dest[0]:
            # πύργοι στην ίδια στήλη (ίδιο letter)
            # 1. rook rank < move
            if src[1] < dest[1]:
                for num in self.ranks:
                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                    if num <= src[1] or num >= dest[1]:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    if self.brd.squares[src[0] + num]:
                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                        # αναζήτηση
                        return False
                else:
                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                    return True

            # 2. rook rank > move
            if src[1] > dest[1]:
                for num in self.ranks:
                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                    if num <= dest[1] or num >= src[1]:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    if self.brd.squares[src[0] + num]:
                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                        # αναζήτηση
                        return False
                else:
                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                    return True

        elif src[1] == dest[1]:
            # πύργοι στην ίδια γραμμή (ίδιο number)
            # 1. rook letter > move
            if src[0] > dest[0]:
                for letter in self.files:
                    if letter <= dest[0] or letter >= src[0]:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    if self.brd.squares[letter + src[1]]:
                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                        # αναζήτηση
                        return False
                else:
                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                    return True

            # 2. rook letter < move
            if src[0] < dest[0]:
                for letter in self.files:
                    if letter >= dest[0] or letter <= src[0]:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    if self.brd.squares[letter + str(src[1])]:
                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                        # αναζήτηση
                        return False
                else:
                    # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                    # αναζήτηση
                    return True

    def __knight_move_is_valid(self, src: str, dest: str) -> bool:
        """
        Ελέγχει εάν η κίνηση ενός ίππου είναι έγκυρη
        Για να γίνει αυτό, εξετάζεται εάν η εμβέλεια κίνησης του ίππου είναι νόμιμη
        Διαφορετικά θα μετακινηθεί ο πρώτος που θα βρεθεί στη διαπέραση των κομματιών, και θα εκτελέσει μη νόμιμη κίνηση
        Ορίσματα:
        ---------
            src (str): θέση εκκίνησης (πχ b1)

            dest (str): θέση προορισμού (πχ c3)

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (bool):
                True: η κίνηση είναι έγκυρη
                False: η κίνηση δεν είναι έγκυρη
        """
        # γίνεται αναζήτηση του file (γράμμα) εκκίνησης και προορισμού, και μετατρέπεται σε αριθμητική διαφορά
        distance_by_file = self.files.index(src[0]) - self.files.index(dest[0])
        # γίνεται αναζήτηση του rank (αριθμός) εκκίνησης και προορισμού, και μετατρέπεται σε αριθμητική διαφορά
        distance_by_rank = self.ranks.index(src[1]) - self.ranks.index(dest[1])
        # εάν το ζευγάρι των αριθμητικών αυτών τιμών βρίσκεται μέσα στο προκαθορισμένη λίστα, η κίνηση είναι έγκυρη
        if (distance_by_file, distance_by_rank) in self.knight_moves:
            return True
        # διαφορετικά η κίνηση δεν είναι έγκυρη
        return False

    def __king_move_is_valid(self, src: str, dest: str) -> bool:
        """
        Ελέγχει εάν η κίνηση του βασιλιά είναι έγκυρη
        Ορίσματα:
        ---------
            src (str): θέση εκκίνησης (πχ e4)

            dest (str): θέση προορισμού (πχ e6)

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (bool):
                True: η κίνηση είναι έγκυρη
                False: η κίνηση δεν είναι έγκυρη
        """
        if src == dest:
            # έλεγχος εάν έχουμε ίδια θέση εκκίνησης - προορισμού (δεν επιτρέπεται)
            return False

        # ορισμός μεταβλητών για πιο εύκολη πρόσβαση
        king_file = src[0]
        king_rank = int(src[1])
        dest_file = dest[0]
        dest_rank = int(dest[1])

        # --- οριζόντια κίνηση ---
        if king_file == dest_file:
            # έλεγχος εάν το rank (γραμμή) του βασιλιά έχει διαφορά μία μονάδα
            if king_rank - 1 == dest_rank or king_rank + 1 == dest_rank:
                return True

        # --- κάθετη κίνηση ---
        if king_rank == dest_rank:
            # εύρεση του index του γράμματος μέσα στο self.files, ώστε να "μετατραπούν" σε αριθμητικές τιμές και να
            # γίνει σύγκριση
            king_file_index = self.files.index(king_file)
            dest_file_index = self.files.index(dest_file)
            # έλεγχος εάν το file (στήλη) του βασιλιά έχει διαφορά ένα γράμμα
            if king_file_index - 1 == dest_file_index or king_file_index + 1 == dest_file_index:
                return True

        # --- διαγώνια κίνηση ---
        # αρχικοποίηση βοηθητικής μεταβλητής
        # όταν ενεργοποιηθεί, σημαίνει πως πρέπει να ελεγχθεί το επόμενο κελί
        check_next_flag = False
        for diag in self.diags:
            # έλεγχος εάν και οι δύο θέσεις βρίσκονται στην ίδια διαγώνιο
            if src in diag and dest in diag:
                # βασιλιάς και θέση επίθεσης βρίσκονται στην ίδια διαγώνιο
                # για να μπορεί να εκτελεστεί η κίνηση από αυτό τον βασιλιά, θα πρέπει να είναι το αμέσως επόμενο κελί
                for square in diag:
                    # διατρέχουμε τα κελιά μέχρι να βρούμε το ένα απο τα δύο (κομμάτι ή θέση επίθεσης)
                    if square != src and square != dest and check_next_flag is False:
                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                        continue
                    # όταν βρεθεί το ένα, ενεργοποιείται το flag, ώστε να ελεγχθεί το επόμενο κελί
                    if (square == src or square == dest) and check_next_flag is False:
                        check_next_flag = True
                        continue
                    # όταν το flag ενεργοποιηθεί, ελέγχεται το επόμενο κελί
                    if check_next_flag:
                        # εάν κάποιο από τα κελιά είναι ενεργό, διακόπτεται η αναζήτηση
                        if square == dest or square == src:
                            return True

        # απέτυχαν όλοι οι έλεγχοι, η κίνηση δεν είναι εφικτή
        return False

    def __piece_is_not_pinned(self, src: str, dest: str, tag: str) -> bool:
        """
        Ελέγχει εάν ένα κομμάτι είναι "καρφωμένο"
        Όταν ένα κομμάτι εμποδίζει κάποιο αντίπαλο κομμάτι να κάνει ματ στον βασιλιά, δεν μπορεί να μετακινηθεί εκτός
        της ευθείας/διαγωνίου την οποία καλύπτει και λέγεται πως είναι "καρφωμένο"
        Στη μέθοδο αυτή δημιουργούνται οι ευθείες και οι διαγώνιοι στις οποίες ανήκει ο βασιλιάς, και ελέγχεται αν το
        κομμάτι που θα κινηθεί είναι "καρφωμένο" στον βασιλιά ή όχι

        Ορίσματα:
        ---------
            src (str): θέση εκκίνησης (πχ e4)

            dest (str): θέση προορισμού (πχ e6)

            tag (str): "w"/"b" ανάλογα τον γύρο και τον παίκτη που παίζει

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (bool):
                True: το κομμάτι δεν είναι καθηλωμένο
                False: το κομμάτι είναι καθηλωμένο
        """
        # αποθήκευση θέσης βασιλιά με τη χρήση του λεξικού kings της κλάσης board.Board
        king_pos = self.brd.kings[tag].pos

        # έλεγχος γραμμής ----------------------------------------------------------------------------------------------
        # δημιουργία λίστας με κελιά γραμμής που ανήκει ο βασιλιάς
        king_row: list = []
        for letter in self.files:
            king_row.append(letter + king_pos[1])

        # έλεγχος εάν το κομμάτι που θα κινηθεί βρίσκεται στην ίδια γραμμή με τον βασιλιά
        if src in king_row:
            # το κομμάτι που θα κινηθεί βρίσκεται στην ίδια γραμμή με τον βασιλιά
            # θέσεις του βασιλιά και κομματιού που θα κινηθεί (src) στη λίστα
            king_index = king_row.index(king_pos)
            src_index = king_row.index(src)

            # εάν η θέση src είναι μικρότερη, ξεκινάμε από την επόμενή της και προς τα "αριστερά"
            if src_index < king_index:
                # έλεγχος εάν τα ενδιάμεσα κελιά είναι κενά
                for i in range(king_index - 1, src_index, -1):
                    if self.brd.squares[king_row[i]]:
                        # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                        return True

                for i in range(src_index - 1, -1, -1):
                    # king_row[i] == θέση της λίστας
                    if self.brd.squares[king_row[i]]:
                        # βρέθηκε το πρώτο κατειλημμένο κελί
                        for piece in self.brd.pieces:
                            # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                            if piece.pos == king_row[i]:
                                if piece.name[1] == tag:
                                    # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                    # άρα δεν είναι καρφωμένο
                                    return True
                                else:
                                    if piece.name[0] != "q" and piece.name[0] != "r":
                                        # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                        # δεν είναι καρφωμένο
                                        return True

                                    if piece.name[0] == "q" or piece.name[0] == "r":
                                        if dest in king_row:
                                            # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                            # η κίνηση είναι νόμιμη
                                            return True
                                        # εάν είναι βασίλισσα ή πύργος στην ίδια γραμμή, το κομμάτι είναι "καρφωμένο"
                                        return False

            # εάν η θέση src είναι μεγαλύτερη, ξεκινάμε από την επόμενή της και προς τα "δεξιά"
            if src_index > king_index:
                for i in range(king_index + 1, src_index):
                    if self.brd.squares[king_row[i]]:
                        # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                        return True

                for i in range(src_index + 1, 8):
                    # king_row[i] == θέση της λίστας
                    if self.brd.squares[king_row[i]]:
                        # βρέθηκε το πρώτο κατειλημμένο κελί
                        for piece in self.brd.pieces:
                            # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                            if piece.pos == king_row[i]:
                                # εάν είναι κομμάτι ίδιου χρώματος, δεν είναι καρφωμένο
                                if piece.name[1] == tag:
                                    # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                    # άρα δεν είναι καρφωμένο
                                    return True
                                else:
                                    if piece.name[0] != "q" and piece.name[0] != "r":
                                        # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                        # δεν είναι καρφωμένο
                                        return True
                                    # εάν είναι βασίλισσα ή πύργος στην ίδια γραμμή, το κομμάτι είναι "καρφωμένο"
                                    if piece.name[0] == "q" or piece.name[0] == "r":
                                        if dest in king_row:
                                            # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                            # η κίνηση είναι νόμιμη
                                            return True
                                        # εάν είναι βασίλισσα ή πύργος στην ίδια γραμμή, το κομμάτι είναι "καρφωμένο"
                                        return False

            # το κομμάτι είναι στην ίδια ευθεία, αλλά δε βρέθηκε κάποιο αντίπαλο κομμάτι που να το "καρφώνει",
            # άρα μπορεί να μετακινηθεί
            return True

        # έλεγχος στήλης -----------------------------------------------------------------------------------------------
        # δημιουργία λίστας με κελιά στήλης που ανήκει ο βασιλιάς
        king_col: list = []
        for number in self.ranks:
            king_col.append(king_pos[0] + number)

        # έλεγχος εάν το κομμάτι που θα κινηθεί βρίσκεται στην ίδια στήλη με τον βασιλιά
        if src in king_col:
            # το κομμάτι που θα κινηθεί βρίσκεται στην ίδια στήλη με τον βασιλιά
            # θέσεις του βασιλιά και κομματιού που θα κινηθεί (src) στη λίστα
            king_index = king_col.index(king_pos)
            src_index = king_col.index(src)
            # εάν η θέση src είναι μικρότερη, ξεκινάμε από την επόμενή της και προς τα "κάτω"
            if src_index < king_index:
                for i in range(king_index - 1, src_index, -1):
                    if self.brd.squares[king_col[i]]:
                        # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                        return True

                for i in range(src_index - 1, -1, -1):
                    # king_row[i] == θέση της λίστας
                    if self.brd.squares[king_col[i]]:
                        # βρέθηκε το πρώτο κατειλημμένο κελί
                        for piece in self.brd.pieces:
                            # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                            if piece.pos == king_col[i]:
                                if piece.name[1] == tag:
                                    # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                    # άρα δεν είναι καρφωμένο
                                    return True
                                else:
                                    if piece.name[0] != "q" and piece.name[0] != "r":
                                        # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                        # δεν είναι καρφωμένο
                                        return True

                                    if piece.name[0] == "q" or piece.name[0] == "r":
                                        if dest in king_col:
                                            # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                            # η κίνηση είναι νόμιμη
                                            return True
                                        # εάν είναι βασίλισσα ή πύργος στην ίδια στήλη, το κομμάτι είναι "καρφωμένο"
                                        return False

            # εάν η θέση src είναι μεγαλύτερη, ξεκινάμε από την επόμενή της και προς τα "πάνω"
            if src_index > king_index:
                for i in range(king_index + 1, src_index):
                    if self.brd.squares[king_col[i]]:
                        # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                        return True

                for i in range(src_index + 1, 8):
                    # king_row[i] == θέση της λίστας
                    if self.brd.squares[king_col[i]]:
                        # βρέθηκε το πρώτο κατειλημμένο κελί
                        for piece in self.brd.pieces:
                            # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                            if piece.pos == king_col[i]:
                                if piece.name[1] == tag:
                                    # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                    # άρα δεν είναι καρφωμένο
                                    return True
                                else:
                                    if piece.name[0] != "q" and piece.name[0] != "r":
                                        # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                        # δεν είναι καρφωμένο
                                        return True

                                    if piece.name[0] == "q" or piece.name[0] == "r":
                                        if dest in king_col:
                                            # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                            # η κίνηση είναι νόμιμη
                                            return True
                                        # εάν είναι βασίλισσα ή πύργος στην ίδια γραμμή, το κομμάτι είναι "καρφωμένο"
                                        return False

            # το κομμάτι είναι στην ίδια στήλη, αλλά δε βρέθηκε κάποιο αντίπαλο κομμάτι που να το "καρφώνει",
            # άρα μπορεί να μετακινηθεί
            return True

        # έλεγχος διαγωνίων --------------------------------------------------------------------------------------------
        # δημιουργία λίστας με λίστες με τα κελιά διαγωνίων που ανήκει ο βασιλιάς
        king_diags: list = []
        for diag in self.diags:
            # γίνεται προσθήκη των διαγωνίων που ανήκει ο βασιλιάς, εκτός από τις μικρές (με δύο κελιά)
            # επίσης άμα ο βασιλιάς βρίσκεται σε κάποια γωνία, ανήκει μόνο σε μία διαγώνιο
            if king_pos in diag and len(diag) > 2:
                king_diags.append(diag)

        # διαπέραση διαγωνίων (μπορεί να είναι μία ή δύο)
        for diag in king_diags:
            # έλεγχος εάν το κομμάτι που θα κινηθεί βρίσκεται στην ίδια διαγώνιο με τον βασιλιά
            if src in diag:
                # το κομμάτι που θα κινηθεί βρίσκεται στην ίδια διαγώνιο με τον βασιλιά
                # θέσεις του βασιλιά και κομματιού που θα κινηθεί (src) στη λίστα
                king_index = diag.index(king_pos)
                src_index = diag.index(src)

                # εάν η θέση src είναι μικρότερη, ξεκινάμε από την επόμενή της και προς την αντίθετη μεριά του βασιλιά
                if src_index < king_index:
                    for i in range(king_index - 1, src_index, -1):
                        if self.brd.squares[diag[i]]:
                            # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                            return True

                    for i in range(src_index - 1, -1, -1):
                        # king_row[i] == θέση της λίστας
                        if self.brd.squares[diag[i]]:
                            # βρέθηκε το πρώτο κατειλημμένο κελί
                            for piece in self.brd.pieces:
                                # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                                if piece.pos == diag[i]:
                                    if piece.name[1] == tag:
                                        # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                        # άρα δεν είναι καρφωμένο
                                        return True
                                    else:
                                        if piece.name[0] != "q" and piece.name[0] != "b":
                                            # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                            # δεν είναι καρφωμένο
                                            return True
                                        # εάν είναι βασίλισσα ή αξ/κός στην ίδια διαγώνιο, το κομμάτι είναι "καρφωμένο"
                                        if piece.name[0] == "q" or piece.name[0] == "b":
                                            if dest in diag:
                                                # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                                # η κίνηση είναι νόμιμη
                                                return True
                                            # εάν είναι βασίλισσα ή αξιωματικός στην ίδια διαγώνιο,
                                            # το κομμάτι είναι "καρφωμένο"
                                            return False

                # εάν η θέση src είναι μεγαλύτερη, ξεκινάμε από την επόμενή της και προς την αντίθετη μεριά του βασιλιά
                if src_index > king_index:
                    for i in range(king_index + 1, src_index):
                        if self.brd.squares[diag[i]]:
                            # βρέθηκε κάποιο κομμάτι ενδιάμεσα, οπότε δεν είναι "καρφωμένο"
                            return True

                    for i in range(src_index + 1, len(diag)):
                        # king_row[i] == θέση της λίστας
                        if self.brd.squares[diag[i]]:
                            # βρέθηκε το πρώτο κατειλημμένο κελί
                            for piece in self.brd.pieces:
                                # εύρεση κομματιού που βρίσκεται σε αυτήν τη θέση
                                if piece.pos == diag[i]:
                                    if piece.name[1] == tag:
                                        # εάν βρεθεί κομμάτι ίδιου χρώματος, δεν απειλείται ο βασιλιάς
                                        # άρα δεν είναι καρφωμένο
                                        return True
                                    else:
                                        if piece.name[0] != "q" and piece.name[0] != "b":
                                            # εάν βρεθεί αντίπαλο κομμάτι, αλλά δεν μπορεί να απειλήσει,
                                            # δεν είναι καρφωμένο
                                            return True

                                        if piece.name[0] == "q" or piece.name[0] == "b":
                                            if dest in diag:
                                                # εάν η κίνηση που θα εκτελεστεί, διατηρεί το "κάρφωμα" στο κομμάτι
                                                # η κίνηση είναι νόμιμη
                                                return True
                                            # εάν είναι βασίλισσα ή αξιωματικός στην ίδια διαγώνιο,
                                            # το κομμάτι είναι "καρφωμένο"
                                            return False

                # το κομμάτι είναι στην ίδια διαγώνιο, αλλά δε βρέθηκε κάποιο αντίπαλο κομμάτι που να το "καρφώνει",
                # άρα μπορεί να μετακινηθεί
                return True

        # τελείωσαν όλοι οι βασικοί έλεγχοι και δε βρέθηκε αντίπαλο κομμάτι που να "καρφώνει" το κομμάτι,
        # άρα μπορεί να κινηθεί νόμιμα
        return True
